/*
 * Copyright 2025 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***********************************************************************************************************************
 * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
 * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
 **********************************************************************************************************************/
/*
 * How to set up clock using clock driver functions:
 *
 * 1. Setup clock sources.
 *
 * 2. Set up all selectors to provide selected clocks.
 *
 * 3. Set up all dividers.
 */

/* clang-format off */
/* TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
!!GlobalInfo
product: Clocks v16.0
processor: MCXE31B
package_id: MCXE31BMPB
mcu_data: ksdk2_0
processor_version: 0.2506.10
 * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS **********/
/* clang-format on */

#include "fsl_clock.h"
#include "clock_config.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/

/*******************************************************************************
 ************************ BOARD_InitBootClocks function ************************
 ******************************************************************************/
void BOARD_InitBootClocks(void)
{
    BOARD_BootClockRUN();
}

/* clang-format off */
/* TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
!!Configuration
name: BOARD_BootClockRUN
called_from_default_init: true
outputs:
- {id: AIPS_PLAT_CLK.outFreq, value: 80 MHz}
- {id: AIPS_SLOW_CLK.outFreq, value: 40 MHz}
- {id: CLKOUT_STANDBY.outFreq, value: 24 MHz}
- {id: CORE_CLK.outFreq, value: 160 MHz}
- {id: DCM_CLK.outFreq, value: 40 MHz}
- {id: EMAC_RX_CLK.outFreq, value: 48 MHz}
- {id: EMAC_TS_CLK.outFreq, value: 48 MHz}
- {id: EMAC_TX_CLK.outFreq, value: 48 MHz}
- {id: FIRC_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN0_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN1_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN2_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN3_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN4_PE_CLK.outFreq, value: 48 MHz}
- {id: FLEXCAN5_PE_CLK.outFreq, value: 48 MHz}
- {id: FXOSC_CLK.outFreq, value: 16 MHz}
- {id: HSE_CLK.outFreq, value: 80 MHz}
- {id: LBIST_CLK.outFreq, value: 40 MHz}
- {id: PLL_PHI0_CLK.outFreq, value: 160 MHz}
- {id: PLL_PHI1_CLK.outFreq, value: 160 MHz}
- {id: QSPI_2xSFCK.outFreq, value: 48 MHz}
- {id: QSPI_MEM_CLK.outFreq, value: 160 MHz}
- {id: QSPI_SFCK.outFreq, value: 24 MHz}
- {id: SIRC_CLK.outFreq, value: 32 kHz}
- {id: STM0_CLK.outFreq, value: 48 MHz}
- {id: STM1_CLK.outFreq, value: 48 MHz}
- {id: TRACE_CLK.outFreq, value: 48 MHz}
settings:
- {id: ClockPostInitConfig, value: BOARD_ClockPostConfig}
- {id: ClockPreInitConfig, value: BOARD_ClockPreConfig}
- {id: JTAG_TCK_INIT_Config, value: custom}
- {id: MUX10_CSC_DC_INIT_Config, value: custom}
- {id: MUX11_CSC_DC_INIT_Config, value: custom}
- {id: MUX1_CSC_DC_INIT_Config, value: custom}
- {id: MUX2_CSC_DC_INIT_Config, value: custom}
- {id: MUX3_CSC_DC_INIT_Config, value: custom}
- {id: MUX4_CSC_DC_INIT_Config, value: custom}
- {id: MUX5_CSC_DC_INIT_Config, value: custom}
- {id: MUX6_CSC_DC_INIT_Config, value: custom}
- {id: MUX7_CSC_DC_INIT_Config, value: custom}
- {id: MUX8_CSC_DC_INIT_Config, value: custom}
- {id: MUX9_CSC_DC_INIT_Config, value: custom}
- {id: SXOSC_INIT_Config, value: custom}
- {id: CORE_PLLODIV_0_DE, value: Enabled}
- {id: CORE_PLLODIV_1_DE, value: Enabled}
- {id: CORE_PLL_PD, value: Power_up}
- {id: FXOSC_PM, value: Crystal_mode}
- {id: MC_CGM.MUX_0_CSC.sel, value: PLL.PLL_PHI0_CLK}
- {id: MC_CGM.MUX_0_DC_1.scale, value: '2', locked: true}
- {id: MC_CGM.MUX_0_DC_2.scale, value: '4', locked: true}
- {id: MC_CGM.MUX_0_DC_3.scale, value: '2', locked: true}
- {id: MC_CGM.MUX_0_DC_4.scale, value: '4', locked: true}
- {id: MC_CGM.MUX_6_DC_0.scale, value: '4', locked: true}
- {id: MUX_0_DC_0_Trigger, value: Common}
- {id: MUX_0_DC_1_Trigger, value: Common}
- {id: MUX_0_DC_2_Trigger, value: Common}
- {id: MUX_0_DC_3_Trigger, value: Common}
- {id: MUX_0_DC_4_Trigger, value: Common}
- {id: MUX_0_DC_5_Trigger, value: Common}
- {id: MUX_0_DC_6_Trigger, value: Common}
- {id: PLL.CORE_MFD.scale, value: '120', locked: true}
- {id: PLL.ODIV2.scale, value: '2', locked: true}
- {id: PLL.PLLODIV_0.scale, value: '3', locked: true}
- {id: PLL.PLLODIV_1.scale, value: '3', locked: true}
- {id: PLL.PLL_PREDIV.scale, value: '2', locked: true}
sources:
- {id: FXOSC.FXOSC.outFreq, value: 16 MHz, enabled: true}
 * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS **********/
/* clang-format on */

const fxosc_config_t g_fxoscConfig_BOARD_BootClockRUN =
    {
        .freqHz = 16000000,                       /* FXOSC output clock frequency: 16000000Hz */
        .workMode = kFXOSC_ModeCrystal,           /* Crystal mode */
        .startupDelay = 49,                       /* FXOSC startup delay: 49counts */
        .overdriveProtect = 12                    /* FXOSC overdrive protection: 12 */
    };
const pll_config_t g_pllConfig_BOARD_BootClockRUN =
    {
        .workMode = kPLL_ModeInteger,             /* PLL operates in integer-only mode */
        .preDiv = 2,                              /* PLL input clock predivider: 2 */
        .postDiv = 2,                             /* PLL output clock divider: 2 */
        .multiplier = 120,                        /* PLL output clock divider: 120 */
        .fracLoopDiv = 0,                         /* PLL fractional loop numerator: 0 */
        .stepSize = 0,                            /* SSCG mode frequency modulation step size: 0 */
        .stepNum = 0,                             /* SSCG mode number of steps of modulation period: 0 */
        .accuracy = kPLL_UnlockAccuracy9,         /* Unlock range = Expected value deviates by 9 (recommended when PLLFM[SSCGBYP] = 1). */
        .outDiv = {3, 3}                          /* PLL Output Divider: 3, 3*/
    };
const clock_pcfs_config_t g_pcfsConfig_BOARD_BootClockRUN =
    {
        .maxAllowableIDDchange = 50,              /* Maximum variation of current per time: 50 mA/microsec */
        .stepDuration = 1,                        /* Step duration of each PCFS step: 1 us/step */
        .clkSrcFreq = 160000000                   /* Frequency of the clock source from which ramp-down and to which ramp-up are processed: 160000000 Hz */
    };
/*******************************************************************************
 * Code for BOARD_BootClockRUN configuration
 ******************************************************************************/
void BOARD_BootClockRUN_InitClockModule(clock_module_t module)
{
    switch(module) {
        case kClockModule_FIRC:
            /* Switch the FIRC_DIV_SEL to the desired diveder. */
            if (((CONFIGURATION->CONFIG_REG_GPR & CONFIGURATION_CONFIG_REG_GPR_APP_CORE_ACC_MASK) >> CONFIGURATION_CONFIG_REG_GPR_APP_CORE_ACC_SHIFT) == 0x5) {
               CONFIGURATION->CONFIG_REG_GPR = (CONFIGURATION->CONFIG_REG_GPR & ~CONFIGURATION_CONFIG_REG_GPR_FIRC_DIV_SEL_MASK) | CONFIGURATION_CONFIG_REG_GPR_FIRC_DIV_SEL(3);}
            /* Disable FIRC in standby mode. */
            CLOCK_DisableFircInStandbyMode();
            break;
        case kClockModule_SIRC:
            /* Disable SIRC in standby mode. */
            CLOCK_DisableSircInStandbyMode();
            break;
        case kClockModule_FXOSC:
            /* Enable FXOSC. */
            CLOCK_InitFxosc(&g_fxoscConfig_BOARD_BootClockRUN);
            break;
        case kClockModule_PLL:
            /* Enable PLL. */
            CLOCK_InitPll(&g_pllConfig_BOARD_BootClockRUN);
            break;
        case kClockModule_MUX0_CSC_DC:
            CLOCK_SelectSafeClock(kFIRC_CLK_to_MUX0);
            /* Configure MUX_0_CSC dividers */
            CLOCK_SetClkMux0DivTriggerType(KCLOCK_CommonTriggerUpdate);
            CLOCK_SetClkDiv(kCLOCK_DivCoreClk, 1U);
            CLOCK_SetClkDiv(kCLOCK_DivAipsPlatClk, 2U);
            CLOCK_SetClkDiv(kCLOCK_DivAipsSlowClk, 4U);
            CLOCK_SetClkDiv(kCLOCK_DivHseClk, 2U);
            CLOCK_SetClkDiv(kCLOCK_DivDcmClk, 4U);
            CLOCK_SetClkDiv(kCLOCK_DivLbistClk, 4U);
            CLOCK_SetClkDiv(kCLOCK_DivQspiClk, 1U);
            CLOCK_CommonTriggerClkMux0DivUpdate();
            CLOCK_ProgressiveClockFrequencySwitch( kPLL_PHI0_CLK_to_MUX0, &g_pcfsConfig_BOARD_BootClockRUN);
            break;
        default:
            assert(false);
            break;
    }
}

void BOARD_BootClockRUN(void)
{
    BOARD_ClockPreConfig();
    BOARD_BootClockRUN_InitClockModule(kClockModule_FIRC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_SIRC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_FXOSC);
    BOARD_BootClockRUN_InitClockModule(kClockModule_PLL);
    BOARD_BootClockRUN_InitClockModule(kClockModule_MUX0_CSC_DC);
    BOARD_ClockPostConfig();
    /*!< Set SystemCoreClock variable. */
    SystemCoreClockUpdate();
}

